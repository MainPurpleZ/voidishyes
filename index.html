<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID - PROVE IT THEN</title>
    <!-- Import VHS-style font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'VT323', monospace;
        }

        canvas {
            display: block;
        }

        /* Hidden source canvas */
        #sourceCanvas {
            display: none;
        }

        /* The WebGL display canvas */
        #glCanvas {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Optional UI overlay for interaction if needed later */
        #ui {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #333;
            font-size: 12px;
            pointer-events: none;
            opacity: 0.5;
        }
    </style>
</head>
<body>

    <!-- This canvas holds the raw text with bloom (glow) -->
    <canvas id="sourceCanvas"></canvas>
    
    <!-- This canvas renders the shader effects -->
    <canvas id="glCanvas"></canvas>

    <div id="ui">SIGNAL_LOST // 0X004</div>

    <!-- Vertex Shader -->
    <script id="vertShader" type="x-shader/x-vertex">
        attribute vec2 position;
        varying vec2 vUv;
        void main() {
            vUv = position * 0.5 + 0.5;
            // Flip Y because WebGL texture coords are often flipped relative to Canvas
            vUv.y = 1.0 - vUv.y;
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader (The Magic) -->
    <script id="fragShader" type="x-shader/x-fragment">
        precision highp float;
        
        uniform sampler2D uTexture;
        uniform float uTime;
        uniform vec2 uResolution;
        uniform vec2 uMouse;
        
        varying vec2 vUv;

        // Random noise function
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        // 2D Noise
        float noise(in vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f*f*(3.0-2.0*f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        void main() {
            vec2 uv = vUv;
            
            // 1. Lens Distortion (Barrel)
            // Center the UVs
            vec2 distUV = uv - 0.5;
            
            // Calculate distance from center
            float dist = length(distUV);
            
            // Apply cubic distortion
            // Strength of distortion
            float distortionStrength = 0.15 + (sin(uTime * 0.5) * 0.02); 
            
            // Distorted coordinates
            vec2 distortedUV = uv + distUV * (dist * dist * distortionStrength);
            
            // 2. Chromatic Aberration
            // Split RGB based on distance from center + slight oscillation
            float aberrStrength = 0.015 * dist * 3.0; // More aberration at edges
            
            vec2 redUV = distortedUV - vec2(aberrStrength, 0.0);
            vec2 blueUV = distortedUV + vec2(aberrStrength, 0.0);
            
            // Sample texture
            // Bounds check to prevent streaking at edges
            vec4 col = vec4(0.0);
            
            if (distortedUV.x > 0.0 && distortedUV.x < 1.0 && distortedUV.y > 0.0 && distortedUV.y < 1.0) {
                float r = texture2D(uTexture, redUV).r;
                float g = texture2D(uTexture, distortedUV).g;
                float b = texture2D(uTexture, blueUV).b;
                
                // Add a "ghosting" trail effect (simple version)
                // r += texture2D(uTexture, redUV - vec2(0.01, 0.0)).r * 0.3;
                
                col = vec4(r, g, b, 1.0);
            }
            
            // 3. Scanlines
            float scanlineCount = uResolution.y * 0.5;
            float scanline = sin(distortedUV.y * scanlineCount + uTime * 5.0);
            col.rgb -= scanline * 0.15; // Darken scanlines
            
            // 4. VHS Static / Grain
            float grain = random(distortedUV * uTime) * 0.15;
            col.rgb += grain;
            
            // 5. Flicker
            float flicker = noise(vec2(uTime * 20.0, 0.0)) * 0.05 + 0.95;
            col.rgb *= flicker;
            
            // 6. Vignette (Dark corners)
            float vignette = smoothstep(1.2, 0.4, dist);
            col.rgb *= vignette;
            
            // 7. Bloom Boost (Enhance brights from source)
            // The source texture already has glow, but we can pump the gamma
            col.rgb = pow(col.rgb, vec3(0.9)); 

            gl_FragColor = col;
        }
    </script>

    <script>
        const sourceCanvas = document.getElementById('sourceCanvas');
        const sourceCtx = sourceCanvas.getContext('2d');
        const glCanvas = document.getElementById('glCanvas');
        const gl = glCanvas.getContext('webgl');

        let width = window.innerWidth;
        let height = window.innerHeight;
        let time = 0;
        let mouseX = 0;
        let mouseY = 0;

        // --- 1. Source Canvas Setup (The "Texture") ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            
            // Match resolution for sharp text
            sourceCanvas.width = width;
            sourceCanvas.height = height;
            glCanvas.width = width;
            glCanvas.height = height;
            
            gl.viewport(0, 0, width, height);
            
            drawSource();
        }

        function drawSource() {
            // Clear background (black)
            sourceCtx.fillStyle = '#000000';
            sourceCtx.fillRect(0, 0, width, height);
            
            // Configure Text
            // Dynamic font size based on width
            const fontSize = Math.min(width * 0.15, 120); 
            sourceCtx.font = `${fontSize}px 'VT323', monospace`;
            sourceCtx.textAlign = 'center';
            sourceCtx.textBaseline = 'middle';
            
            const text = "PROVE IT THEN.";
            const cx = width / 2;
            const cy = height / 2;

            // --- Bloom Effect (Layering Shadows) ---
            
            // Layer 1: Deep wide glow (Red/Purplish)
            sourceCtx.shadowColor = 'rgba(255, 0, 50, 0.8)';
            sourceCtx.shadowBlur = 40;
            sourceCtx.fillStyle = '#FFFFFF';
            sourceCtx.fillText(text, cx, cy);
            
            // Layer 2: Tight bright glow (Cyan/Blue)
            sourceCtx.shadowColor = 'rgba(0, 255, 255, 0.9)';
            sourceCtx.shadowBlur = 15;
            sourceCtx.fillStyle = '#FFFFFF';
            sourceCtx.fillText(text, cx, cy);

            // Layer 3: Solid Core
            sourceCtx.shadowBlur = 0;
            sourceCtx.fillStyle = '#EEFFFF'; // Almost white
            sourceCtx.fillText(text, cx, cy);
            
            // Update the WebGL texture
            if(texture) {
                updateTexture();
            }
        }

        // --- 2. WebGL Setup ---
        
        if (!gl) {
            console.error("WebGL not supported");
        }

        // Compile Shader Function
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader Compile Error:", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Setup Program
        const vertSource = document.getElementById('vertShader').text;
        const fragSource = document.getElementById('fragShader').text;
        
        const vertShader = compileShader(vertSource, gl.VERTEX_SHADER);
        const fragShader = compileShader(fragSource, gl.FRAGMENT_SHADER);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Buffers (Full screen quad)
        const vertices = new Float32Array([
            -1.0, -1.0,
             1.0, -1.0,
            -1.0,  1.0,
            -1.0,  1.0,
             1.0, -1.0,
             1.0,  1.0
        ]);
        
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Uniforms
        const uTime = gl.getUniformLocation(program, "uTime");
        const uResolution = gl.getUniformLocation(program, "uResolution");
        const uTexture = gl.getUniformLocation(program, "uTexture");
        
        // Texture Setup
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        function updateTexture() {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            // Flip Y for WebGL
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); 
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceCanvas);
        }

        // --- 3. Animation Loop ---
        
        function animate(now) {
            now *= 0.001; // convert to seconds
            time = now;
            
            // Optionally jitter the source text slightly for VHS instability
            if (Math.random() > 0.95) {
                drawSource(); // Redraw static text occasionally if we wanted it to change
            }
            
            gl.uniform1f(uTime, time);
            gl.uniform2f(uResolution, width, height);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            requestAnimationFrame(animate);
        }

        // Listeners
        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Fonts load async, so wait a moment or use font loader. 
        // Simple hack: wait for window load + a small delay to ensure font applies
        window.onload = () => {
             // Force a few redraws to catch the font loading
             resize();
             setTimeout(resize, 500);
             setTimeout(resize, 1000);
             requestAnimationFrame(animate);
        };

    </script>
</body>
</html>
